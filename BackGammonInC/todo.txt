Kolla vilket drag so utesluts
Man borde kunna hoppa över kort sets på en gång.
Olika buffrar för doubles och vanliga tärningar.
moveSet->LongestSet, ta bort func RemoveShorterSets och hoppa över specialfallen i REcursiveSearch

Alpha beta pruning
------------------
	Performance depth 2 Eval count: 6236575 - (374.4k evs/sec) 16660.00ms
	Performance Eval count: 5836794 - (479.3k evs/sec) 12177.00ms

	- Fler testfall4/10

	- Light Score på move set.
		- points left
		- minus för blots på to-moves
	
	- Sortera movesets på 
		hits
		quads i par.
		tp_moves som sparas i hash-tabell
				
	- Iterative deepening

	- Store PV-moves in Hash-table


det kanske inte är så viktigt att generera alla tärningar?
	dubblar

Trainer, genetic search
-----------------------
	- Save & Load Genes
	- ai0 black, sen ai1 black. Byt plats.

Regressionstest
---------------
	Depth 1 vinner över depth 0
		Black
		White
	
	Hashing snabbare, men fortfarande jämn match
		Black
		White

	Pruning

Multithreading i trainer
------------------------
	Paralella games.
	Träna utan quads?

Flytta CheckerCountAssert till GameConfig

Can move generation för quads göras smartare?


DONE
====================================================================
Check if there are duplicates when generating from quad dice
	- Done
	- If many, do hashing
	- Many duplicates

Look ahead.
	- Generate all possible dice.
	- Probabillity score. Take average score, för motståndaren.
	- funkar

Varför vinner black 52%?
	- Bugg: >> 4 skulle vara >> 5
	- För många drag generades

	
Bara hasha för quads.
	Beräkna games/sec och %
	- ingen skillnad prestandamässigt
	
Config för
	Game
		- Print Game
		- Quads
		- No of threads

	AI
		- Hashing Sets, villkor
		- Search Depth	
		- Prune, sortering? Kan det ske på bara djup 1?

Inte jobba med Game* utan matriser, prestanda
	- Blev 4% sämre prestanda